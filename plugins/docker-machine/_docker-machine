#compdef docker-machine

__docker-machine_stoppedmachines() {
    __docker-machine_get_machines stopped "$@"
}

__docker-machine_runningmachines() {
    __docker-machine_get_machines running "$@"
}

__docker-machine_machines () {
    __docker-machine_get_machines all "$@"
}

__docker-machine_caching_policy() {
    oldp=( "$1"(Nmh+1) )     # 1 hour
    (( $#oldp ))
}

__docker-machine_get_machines() {
    local kind expl
    declare -a running stopped args machines

    kind=$1
    shift
    [[ $kind = (stopped|all) ]] && args=($args -a)

    machines=(${(f)"$(_call_program commands docker-machine 2>/dev/null ${machine_path:+-s $machine_path} ls)"})

    # Parse header line to find columns
    local i=1 j=1 k header=${machines[1]}
    declare -A begin end
    while (( $j < ${#header} - 1 )) {
        i=$(( $j + ${${header[$j,-1]}[(i)[^ ]]} - 1))
        j=$(( $i + ${${header[$i,-1]}[(i)  ]} - 1))
        k=$(( $j + ${${header[$j,-1]}[(i)[^ ]]} - 2))
        begin[${header[$i,$(($j-1))]}]=$i
        end[${header[$i,$(($j-1))]}]=$k
    }
    machines=(${machines[2,-1]})

    # Container ID
    local line s name
    local -a names
    for line in $machines; do
        if [[ $machines == *"${line[${begin[NAME]},${end[ERRORS]}]%% ##}"* ]]; then
            name=${line[${begin[NAME]},${end[NAME]}]%% ##}
            state=${line[${begin[STATE]},${end[STATE]}]}
            if [[ $state = Running* ]]; then
                running=($running $name)
            else
                stopped=($stopped $name)
            fi
        fi
    done

    [[ $kind = (running|all) ]] && _describe -t machines-running "running machines" running
    [[ $kind = (stopped|all) ]] && _describe -t machines-stopped "stopped machines" stopped
}

__docker-machine_subcommand () {
    local -a _command_args
    integer ret=1
    case "$words[1]" in
        (env)
            _arguments \
                '--swarm[show swarm env vars instead]' \
                '--shell[Use a different shell language, ie. powershell]' \
                '1:running machines:__docker-machine_runningmachines' && ret=0
            ;;
        (ls)
            _arguments \
                '--filter[Filter machines]' \
                '-q[Only display IDs]' && ret=0
            ;;
        (*)
            _message 'Unknown sub command'
    esac

    return ret
}

__docker-machine_commands () {
    local cache_policy

    zstyle -s ":completion:${curcontext}:" cache-policy cache_policy
    if [[ -z "$cache_policy" ]]; then
        zstyle ":completion:${curcontext}:" cache-policy __docker-machine_caching_policy
    fi

    if ( [[ ${+_docker_machine_subcommands} -eq 0 ]] || _cache_invalid docker_machine_subcommands) \
        && ! _retrieve_cache docker_machine_subcommands ;
    then
        local -a lines
        lines=(${(f)"$(_call_program commands docker-machine 2>&1 | sed 's/	/ /g' )"})
        _docker_machine_subcommands=(${${${lines[$((${lines[(i)Commands:]} + 1)),${lines[(I)  *]}]}## #}/ ##/:})
        _store_cache docker_machine_subcommands _docker_machine_subcommands
    fi
    _describe -t docker-machine-commands "docker-machine command" _docker_machine_subcommands
}

_docker-machine () {
    # Support for subservices, which allows for `compdef _docker docker-shell=_docker_containers`.
    # Based on /usr/share/zsh/functions/Completion/Unix/_git without support for `ret`.
    if [[ $service != docker-machine ]]; then
        _call_function - _$service
        return
    fi

    local curcontext="$curcontext" state line ret=1
    typeset -A opt_args

    _arguments -C \
        '(- :)'{-h,--help}'[Get help]' \
        '--debug[Show more output]' \
        '(- :)'{-v,--version}'[Print version and exit]' \
        '(-s --storage-path)'{-f,--file}'[Specify an alternate docker-machine storage path]:file:_files -g "**/machines"' \
        '(-): :->command' \
        '(-)*:: :->option-or-argument' && ret=0

    local counter=1
    #local machine_path
    while [ $counter -lt ${#words[@]} ]; do
        case "${words[$counter]}" in
            -s|--storage-path)
                (( counter++ ))
                machine_path="${words[$counter]}"
                ;;
            *)
                ;;
        esac
        (( counter++ ))
    done

    case $state in
        (command)
            __docker-machine_commands && ret=0
            ;;
        (option-or-argument)
            curcontext=${curcontext%:*:*}:docker-machine-$words[1]:
            __docker-machine_subcommand && ret=0
            ;;
    esac

}

_docker-machine "$@"
